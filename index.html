<!doctype html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>WordFlux Â· a tiny Wordle clone</title>
  <meta name="description" content="A Wordle-style game.">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root{
      /* Palette */
      --gg-bg:#0c1020;
      --gg-card:#121735;
      --gg-ink:#eef1ff;
      --gg-ink-dim:#b9c6ef;
      --gg-outline:#86a6ff;
      --gg-border:#2b3868;

      /* Tile colors */
      --tile-correct:#3fb57f;
      --tile-present:#d1a341;
      --tile-absent:#3a4372;
      --tile-idle:#0f1439;

      /* Sizing knob shared by board + keyboard */
      --board-max: 560px;
      --k-gap:.5rem;
    }

    html,body{height:100%}
    body{
      background: var(--gg-bg);
      color: var(--gg-ink);
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      overflow-x: hidden;
    }
    /* gradient backdrop */
    body::before{
      content:""; position:fixed; inset:0; z-index:-1; pointer-events:none;
      background:
        radial-gradient(1200px 600px at 12% -10%, #273056 0%, rgba(23,26,38,0) 60%),
        radial-gradient(1200px 600px at 88% 110%, #1f2648 0%, rgba(23,26,38,0) 55%);
      background-repeat:no-repeat; background-attachment: fixed;
    }

    .gg-card{ background:linear-gradient(180deg,#151c3b,#13183a); border:1px solid var(--gg-border); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    .gg-badge{ background:#1a2147; color:#a6b6f0; border:1px solid var(--gg-border); }
    .gg-muted{ color:var(--gg-ink-dim); }

    /* Board */
    .board{ display:grid; grid-template-rows: repeat(6, 1fr); gap:.6rem; width:min(100%, var(--board-max)); margin-inline:auto; }
    .row{ display:grid; grid-template-columns: repeat(5, 1fr); gap:.6rem; }
    .tile{
      aspect-ratio:1/1; display:grid; place-items:center; font-weight:800; font-size:28px; text-transform:uppercase;
      border-radius:.8rem; background:var(--tile-idle); border:1px solid #3a4681; color:#ffffff; letter-spacing:1px;
      user-select:none; transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
      cursor: default;
    }
    .tile.filled{ border-color:#5260a4; }
    .tile.reveal{ animation: flip .5s ease forwards; transform-style:preserve-3d; }
    @keyframes flip{ 0%{ transform: rotateX(0); } 49%{ transform: rotateX(90deg); } 51%{ transform: rotateX(90deg);} 100%{ transform: rotateX(0);} }
    .tile.correct{ background:var(--tile-correct); border-color:var(--tile-correct); }
    .tile.present{ background:var(--tile-present); border-color:var(--tile-present); }
    .tile.absent{ background:var(--tile-absent); border-color:var(--tile-absent); color:#c9d2ff; }
    .tile.active{ outline:2px solid var(--gg-outline); box-shadow:0 0 0 3px rgba(134,166,255,.25) inset; }
    .tile.can-edit{ cursor:pointer; }

    /* Keyboard (physical QWERTY layout, responsive) */
    .kbd{ width:min(100%, var(--board-max)); margin:0 auto; padding:0 .25rem; }
    .kbd-row{ display:flex; justify-content:center; align-items:center; gap:var(--k-gap); }
    .key{ flex:1 1 0; min-width:0; background:#10173b; color:#ffffff; border:1px solid var(--gg-border); border-radius:.6rem; padding:.6rem .55rem; font-weight:700; cursor:pointer; font-size:clamp(12px, 2.2vw, 18px); white-space:nowrap; }
    .key[data-state="correct"]{ background:var(--tile-correct); border-color:var(--tile-correct); }
    .key[data-state="present"]{ background:var(--tile-present); border-color:var(--tile-present); }
    .key[data-state="absent"]{ background:var(--tile-absent); border-color:var(--tile-absent); color:#c9d2ff; }
    .key.wide{ flex:1.5 1 0; }
    .spacer{ flex:.5 0 0; }

    /* Panels */
    .panel{ padding:1rem; overflow:hidden; }
    .stat-pill{ background:#0f1432; border:1px solid var(--gg-border); border-radius:999px; padding:.3rem .65rem; color:#dce7ff; }
    .toastify{ position:fixed; top:16px; left:50%; transform:translateX(-50%); background:#0f1432; color:#fff; border:1px solid var(--gg-border); border-radius:.75rem; padding:.5rem .8rem; z-index:1100; box-shadow:0 10px 30px rgba(0,0,0,.45); }

    /* Compact breakpoints for phones: scale board+keyboard together via --board-max and tighten gaps */
    @media (max-width: 480px){
      :root { --board-max: 440px; --k-gap:.45rem; }
      .row{ gap:.5rem; } .board{ gap:.5rem; }
      .tile{ font-size:24px; }
    }
    @media (max-width: 390px){
      :root { --board-max: 400px; --k-gap:.4rem; }
      .row{ gap:.45rem; } .board{ gap:.45rem; }
      .tile{ font-size:22px; }
    }
    @media (max-width: 340px){
      :root { --board-max: 360px; --k-gap:.35rem; }
      .row{ gap:.4rem; } .board{ gap:.4rem; }
      .tile{ font-size:20px; }
    }
  </style>
</head>
<body>
  <!-- NAV -->
  <nav class="navbar navbar-expand-md bg-body-tertiary border-bottom border-dark-subtle sticky-top">
    <div class="container-lg">
      <a class="navbar-brand fw-bold" href="#">WordFlux</a>
      <span class="navbar-text small text-secondary ms-1">a tiny Wordle clone</span>
      <div class="ms-auto d-flex align-items-end gap-2">
        <button id="btnHelp" class="btn btn-outline-info btn-sm">How to play</button>
        <button id="btnStats" class="btn btn-outline-info btn-sm">Stats</button>
        <div class="ms-2">
          <label class="form-label small text-secondary mb-0">Mode</label>
          <select id="modeSelect" class="form-select form-select-sm bg-dark text-light border-secondary">
            <option value="daily">Daily</option>
            <option value="random">Random</option>
          </select>
        </div>
      </div>
    </div>
  </nav>

  <main class="container-lg my-4">
    <section class="gg-card p-3 mb-3" aria-labelledby="gameTitle">
      <div class="d-flex align-items-center gap-2 pb-2 border-bottom" style="border-color:var(--gg-border) !important;">
        <span class="badge rounded-pill gg-badge" id="gameTitle">Daily Puzzle</span>
        <div class="ms-auto d-flex flex-wrap gap-2">
          <button id="btnNew" class="btn btn-success btn-sm">New word</button>
        </div>
      </div>

      <div class="panel">
        <div class="board" id="board" aria-label="Word grid"></div>
        <div class="mt-3" id="keyboard" class="kbd" aria-label="On-screen keyboard"></div>
      </div>
    </section>
  </main>

  <!-- Help Modal -->
  <div class="modal fade" id="helpModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered"><div class="modal-content bg-dark text-light border-0">
      <div class="modal-header border-0"><h5 class="modal-title">How to play</h5><button class="btn-close btn-close-white" data-bs-dismiss="modal"></button></div>
      <div class="modal-body">
        <ol class="small mb-0">
          <li>Guess the fiveâ€‘letter word in six tries.</li>
          <li>Each guess must be a valid word; press <b>Enter</b> to submit.</li>
          <li>Tile colors show how close your guess was: <span class="stat-pill" style="background:var(--tile-correct); border-color:var(--tile-correct)">correct</span> â€¢ <span class="stat-pill" style="background:var(--tile-present); border-color:var(--tile-present)">present</span> â€¢ <span class="stat-pill" style="background:var(--tile-absent); border-color:var(--tile-absent)">absent</span>.</li>
        </ol>
      </div>
    </div></div>
  </div>

  <!-- Stats Modal -->
  <div class="modal fade" id="statsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered"><div class="modal-content bg-dark text-light border-0">
      <div class="modal-header border-0"><h5 class="modal-title">Stats</h5><button class="btn-close btn-close-white" data-bs-dismiss="modal"></button></div>
      <div class="modal-body">
        <div class="d-flex flex-wrap gap-2 mb-2">
          <span class="stat-pill" id="statPlayed">Played 0</span>
          <span class="stat-pill" id="statWin">Wins 0</span>
          <span class="stat-pill" id="statStreak">Streak 0</span>
        </div>
        <div class="small gg-muted">Stats are stored in your browser.</div>
      </div>
    </div></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
  "use strict";
  // ===== Word lists (loaded from the web) =====
  const WORD_SOURCES = {
    allowed: [
      'https://raw.githubusercontent.com/tabatkins/wordle-list/main/words',
      'https://darkermango.github.io/5-Letter-words/words.txt'
    ],
    common: [
      'https://gist.githubusercontent.com/shmookey/b28e342e1b1756c4700f42f17102c2ff/raw/'
    ]
  };

  // Fallbacks if network fails
  let SOLUTIONS = ['CRANE','MAGIC','RAVEN','PIXEL','PLANT','SOUND','TRACE','CLOUD','BRAVE','FRAME'];
  let ALLOWED = new Set(SOLUTIONS);

  const LINE_SPLIT = /\r?\n/;
  const parseLines = (txt)=> txt
      .replace(/\u0000/g,'')
      .split(LINE_SPLIT)
      .map(s=> s.trim().toUpperCase())
      .filter(w=> /^[A-Z]{5}$/.test(w));

  async function loadWordLists(){
    try{
      const fetchText = async (url)=> (await fetch(url, {cache:'force-cache'})).text();
      let allowed = [];
      for(const url of WORD_SOURCES.allowed){
        try{ const t = await fetchText(url); allowed = allowed.concat(parseLines(t)); }catch(e){ console.warn('Failed allowed src', url, e); }
      }
      let common = [];
      for(const url of WORD_SOURCES.common){
        try{ const t = await fetchText(url); common = common.concat(parseLines(t)); }catch(e){ console.warn('Failed common src', url, e); }
      }
      if(allowed.length){ ALLOWED = new Set(allowed); }
      if(common.length){ SOLUTIONS = Array.from(new Set(common)); }
      console.log('Loaded words:', {allowed: ALLOWED.size, solutions: SOLUTIONS.length});
    }catch(err){ console.warn('Word list load failed, using fallbacks', err); }
  }

  // ===== State =====
  const rows = 6, cols = 5;
  let board = [];     // strings per row
  let cursor = 0;     // index within current row
  let row = 0;        // current row
  let solution = 'CRANE'; // replaced in init
  let finished = false;

  const els = {
    board: document.getElementById('board'),
    keyboard: document.getElementById('keyboard'),
    btnNew: document.getElementById('btnNew'),
    btnStats: document.getElementById('btnStats'),
    btnHelp: document.getElementById('btnHelp'),
    statPlayed: document.getElementById('statPlayed'),
    statWin: document.getElementById('statWin'),
    statStreak: document.getElementById('statStreak'),
    modeSelect: document.getElementById('modeSelect'),
  };

  // ===== UI build =====
  function buildBoard(){
    board = Array.from({length:rows}, ()=>Array(cols).fill(''));
    els.board.innerHTML = '';
    for(let r=0;r<rows;r++){
      const line = document.createElement('div'); line.className = 'row';
      for(let c=0;c<cols;c++){
        const t = document.createElement('div'); t.className = 'tile'; t.dataset.r=r; t.dataset.c=c; t.setAttribute('aria-label',`r${r+1} c${c+1}`);
        t.addEventListener('click', ()=> handleTileClick(r,c));
        line.appendChild(t);
      }
      els.board.appendChild(line);
    }
  }

  function buildKeyboard(){
    els.keyboard.innerHTML = '';

    // Row 1: QWERTYUIOP
    const r1 = document.createElement('div');
    r1.className = 'kbd-row';
    for(const ch of 'QWERTYUIOP') r1.appendChild(makeKey(ch));
    els.keyboard.appendChild(r1);

    // Row 2: spacer + ASDFGHJKL + spacer
    const r2 = document.createElement('div');
    r2.className = 'kbd-row';
    r2.appendChild(makeSpacer());
    for(const ch of 'ASDFGHJKL') r2.appendChild(makeKey(ch));
    r2.appendChild(makeSpacer());
    els.keyboard.appendChild(r2);

    // Row 3: ENTER (wide) + ZXCVBNM + DEL (wide)
    const r3 = document.createElement('div');
    r3.className = 'kbd-row';
    r3.appendChild(makeKey('ENTER', true));
    for(const ch of 'ZXCVBNM') r3.appendChild(makeKey(ch));
    r3.appendChild(makeKey('DEL', true));
    els.keyboard.appendChild(r3);

    function makeKey(label, wide=false){
      const b = document.createElement('button');
      b.className = 'key' + (wide?' wide':'');
      b.textContent = label; b.dataset.key = label;
      b.addEventListener('click', ()=> handleKey(label));
      return b;
    }
    function makeSpacer(){ const s=document.createElement('div'); s.className='spacer'; return s; }
  }

  // ===== Game helpers =====
  function pickDailySolution(){
    const d = new Date();
    const seed = d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate();
    const idx = seed % SOLUTIONS.length;
    return SOLUTIONS[idx];
  }
  function pickRandomSolution(){
    return SOLUTIONS[Math.floor(Math.random()*SOLUTIONS.length)];
  }
  function getMode(){ return localStorage.getItem('wf_mode') || 'daily'; }
  function setMode(mode){ localStorage.setItem('wf_mode', mode); }
  function pickSolutionByMode(){ return getMode()==='random' ? pickRandomSolution() : pickDailySolution(); }

  function toast(msg){
    const t = document.createElement('div'); t.className='toastify'; t.textContent = msg;
    document.body.appendChild(t); setTimeout(()=> t.remove(), 1500);
  }

  function paintBoard(){
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
        tile.textContent = board[r][c];
        tile.classList.toggle('filled', !!board[r][c]);
        const isCurrentRow = (r===row && !finished);
        tile.classList.toggle('can-edit', isCurrentRow);
        tile.classList.toggle('active', isCurrentRow && c===cursor);
      }
    }
  }

  async function submitRow(){
    const guess = board[row].join('');
    if(guess.length<cols){ toast('Not enough letters'); return; }
    if(!ALLOWED.has(guess)){ toast('Not in word list'); return; }
    const result = score(guess, solution);
    await revealRow(row, result);
    updateKeyboard(result, guess);
    const won = result.every(x=>x==='correct');
    row++; cursor=0;
    if(won){ endGame(true, guess); }
    else if(row>=rows){ endGame(false, solution); }
    paintBoard();
  }

  function score(guess, target){
    const res = Array(cols).fill('absent');
    const targetCounts = {};
    for(let i=0;i<cols;i++){
      const t = target[i];
      if(guess[i]===t){ res[i]='correct'; }
      else targetCounts[t] = (targetCounts[t]||0)+1;
    }
    for(let i=0;i<cols;i++){
      if(res[i]==='correct') continue;
      const g = guess[i];
      if(targetCounts[g]>0){ res[i]='present'; targetCounts[g]--; }
    }
    return res;
  }

  async function revealRow(r, result){
    for(let c=0;c<cols;c++){
      const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
      await new Promise(resolve=>{
        tile.classList.add('reveal');
        tile.addEventListener('animationend', function handler(){
          tile.removeEventListener('animationend', handler);
          tile.classList.remove('reveal');
          tile.classList.add(result[c]);
          resolve();
        }, {once:true});
      });
    }
  }

  function updateKeyboard(result, guess){
    for(let i=0;i<cols;i++){
      const ch = guess[i];
      const key = els.keyboard.querySelector(`[data-key="${ch}"]`);
      if(!key) continue;
      const prev = key.getAttribute('data-state');
      const now = result[i];
      if(prev==='correct') continue;
      if(prev==='present' && now==='absent') continue;
      key.setAttribute('data-state', now);
    }
  }

  function endGame(won, word){
    finished = true;
    saveStats(won);
    toast(won ? 'You solved it!' : `The word was ${word}`);
    updateStatsUI();
  }

  // ===== Stats =====
  function readStats(){ try{ return JSON.parse(localStorage.getItem('gw_stats')||'{}'); }catch(e){ return {}; } }
  function writeStats(s){ try{ localStorage.setItem('gw_stats', JSON.stringify(s)); }catch(e){} }
  function saveStats(won){
    const s = readStats();
    s.played = (s.played||0)+1;
    s.win = (s.win||0) + (won?1:0);
    s.streak = won ? ( (s.lastWinToday===todayKey()) ? (s.streak||0) : ( (s.lastWin||0)===yesterdayKey() ? (s.streak||0)+1 : 1) ) : 0;
    if(won){ s.lastWin = todayKey(); s.lastWinToday = todayKey(); }
    writeStats(s);
  }
  const todayKey = ()=> new Date().toISOString().slice(0,10);
  const yesterdayKey = ()=>{ const d=new Date(); d.setDate(d.getDate()-1); return d.toISOString().slice(0,10); };
  function updateStatsUI(){
    const s = readStats();
    els.statPlayed.textContent = `Played ${s.played||0}`;
    els.statWin.textContent = `Wins ${s.win||0}`;
    els.statStreak.textContent = `Streak ${s.streak||0}`;
  }

  // ===== Input & editing =====
  function handleKey(k){ if(finished) return; if(k==='ENTER') submitRow(); else if(k==='DEL') backspace(); else if(/^[A-Z]$/.test(k)) type(k); }
  function type(ch){ if(cursor>=cols) return; board[row][cursor]=ch; cursor=Math.min(cursor+1, cols-1); paintBoard(); }
  function backspace(){
    if(cursor>0){ cursor--; board[row][cursor]=''; }
    else { board[row][cursor]=''; }
    paintBoard();
  }
  function setCursor(col){ cursor = Math.max(0, Math.min(cols-1, col)); paintBoard(); }
  function moveLeft(){ setCursor(cursor-1); }
  function moveRight(){ setCursor(cursor+1); }
  function handleTileClick(r,c){ if(finished) return; if(r!==row) return; setCursor(c); }

  document.addEventListener('keydown', (e)=>{
    if(finished) return;
    const key = e.key;
    const k = key.toUpperCase();
    if(key==='ArrowLeft'){ e.preventDefault(); moveLeft(); return; }
    if(key==='ArrowRight'){ e.preventDefault(); moveRight(); return; }
    if(k==='ENTER'){ e.preventDefault(); submitRow(); }
    else if(k==='BACKSPACE'){ e.preventDefault(); backspace(); }
    else if(k==='DELETE'){ e.preventDefault(); board[row][cursor]=''; paintBoard(); }
    else if(/^[A-Z]$/.test(k) && k.length===1){ type(k); }
  });

  // ===== Controls =====
  els.btnNew.addEventListener('click', ()=>{
    const mode = getMode();
    const next = pickSolutionByMode();
    if(mode==='daily' && next===solution){ toast('Daily mode â€” same word for today'); }
    solution = next;
    resetGame();
    toast('New word!');
  });
  els.btnHelp.addEventListener('click', ()=> new bootstrap.Modal(document.getElementById('helpModal')).show());
  els.btnStats.addEventListener('click', ()=>{ updateStatsUI(); new bootstrap.Modal(document.getElementById('statsModal')).show(); });

  function resetGame(){
    finished=false; row=0; cursor=0; buildBoard(); buildKeyboard(); paintBoard();
    document.querySelectorAll('.key').forEach(k=> k.removeAttribute('data-state'));
  }

  // Mode UI wiring
  els.modeSelect.addEventListener('change', ()=>{
    setMode(els.modeSelect.value);
    solution = pickSolutionByMode();
    resetGame();
    toast(`Mode: ${getMode()}`);
  });
  function syncModeUI(){ els.modeSelect.value = getMode(); }

  // ===== Init =====
  (async ()=>{
    await loadWordLists();
    syncModeUI();
    solution = pickSolutionByMode();
    buildBoard(); buildKeyboard(); paintBoard(); updateStatsUI();
  })();
  </script>
</body>
</html>
