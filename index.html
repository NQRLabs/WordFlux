<!doctype html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wordflux · a tiny Wordle clone</title>
  <meta name="description" content="A Wordle-style game in the same visual style as GlyphGrid.">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root{
      /* GlyphGrid-adjacent palette */
      --gg-bg:#0c1020;            /* page background */
      --gg-card:#121735;          /* card background */
      --gg-ink:#eef1ff;           /* primary text */
      --gg-ink-dim:#b9c6ef;       /* secondary text */
      --gg-accent:#7cc9ff;        /* cyan accent */
      --gg-outline:#86a6ff;       /* focus outline */
      --gg-border:#2b3868;        /* card borders */

      /* wordle feedback colors tuned for this palette */
      --tile-correct:#3fb57f;     /* green */
      --tile-present:#d1a341;     /* yellow */
      --tile-absent:#3a4372;      /* gray-blue */
      --tile-idle:#0f1439;        /* default tile */
    }

    html,body{height:100%}
    body{
      background: var(--gg-bg);
      color: var(--gg-ink);
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      overflow-x: hidden;
    }
    /* fixed gradient backdrop like GlyphGrid */
    body::before{
      content:""; position:fixed; inset:0; z-index:-1; pointer-events:none;
      background:
        radial-gradient(1200px 600px at 12% -10%, #273056 0%, rgba(23,26,38,0) 60%),
        radial-gradient(1200px 600px at 88% 110%, #1f2648 0%, rgba(23,26,38,0) 55%);
      background-repeat:no-repeat; background-attachment: fixed;
    }

    .gg-card{ background:linear-gradient(180deg,#151c3b,#13183a); border:1px solid var(--gg-border); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    .gg-badge{ background:#1a2147; color:#a6b6f0; border:1px solid var(--gg-border); }
    .gg-muted{ color:var(--gg-ink-dim); }

    /* Board */
    .board{ display:grid; grid-template-rows: repeat(6, 1fr); gap:.6rem; width:min(460px, 92vw); margin-inline:auto; }
    .row{ display:grid; grid-template-columns: repeat(5, 1fr); gap:.6rem; }
    .tile{
      aspect-ratio:1/1; display:grid; place-items:center; font-weight:800; font-size:28px; text-transform:uppercase;
      border-radius:.8rem; background:var(--tile-idle); border:1px solid #3a4681; color:#ffffff; letter-spacing:1px;
      user-select:none; transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
      cursor: default;
    }
    .tile.filled{ border-color:#5260a4; }
    .tile.reveal{ animation: flip .5s ease forwards; transform-style:preserve-3d; }
    @keyframes flip{ 0%{ transform: rotateX(0); } 49%{ transform: rotateX(90deg); } 51%{ transform: rotateX(90deg);} 100%{ transform: rotateX(0);} }
    .tile.correct{ background:var(--tile-correct); border-color:var(--tile-correct); }
    .tile.present{ background:var(--tile-present); border-color:var(--tile-present); }
    .tile.absent{ background:var(--tile-absent); border-color:var(--tile-absent); color:#c9d2ff; }
    .tile.active{ outline:2px solid var(--gg-outline); box-shadow:0 0 0 3px rgba(134,166,255,.25) inset; }
    .tile.can-edit{ cursor:pointer; }

    /* Keyboard */
    .kbd{ display:grid; gap:.5rem; }
    .kbd-row{ display:flex; gap:.5rem; justify-content:center; }
    .key{ background:#10173b; color:#ffffff; border:1px solid var(--gg-border); border-radius:.6rem; padding:.6rem .7rem; font-weight:700; cursor:pointer; }
    .key[data-state="correct"]{ background:var(--tile-correct); border-color:var(--tile-correct); }
    .key[data-state="present"]{ background:var(--tile-present); border-color:var(--tile-present); }
    .key[data-state="absent"]{ background:var(--tile-absent); border-color:var(--tile-absent); color:#c9d2ff; }
    .key.wide{ padding-inline:1.1rem; }
    @media (max-height: 800px){
      .board{ width:min(420px, 92vw); }
      .tile{ font-size:24px; }
    }

    /* Panels */
    .panel{ padding:1rem; }
    .stat-pill{ background:#0f1432; border:1px solid var(--gg-border); border-radius:999px; padding:.3rem .65rem; color:#dce7ff; }

    /* toasts */
    .toastify{ position:fixed; top:16px; left:50%; transform:translateX(-50%); background:#0f1432; color:#fff; border:1px solid var(--gg-border); border-radius:.75rem; padding:.5rem .8rem; z-index:1100; box-shadow:0 10px 30px rgba(0,0,0,.45); }
  </style>
</head>
<body>
  <!-- NAV -->
  <nav class="navbar navbar-expand-md bg-body-tertiary border-bottom border-dark-subtle sticky-top">
    <div class="container-lg">
      <a class="navbar-brand fw-bold" href="#">Wordflux</a>
      <span class="navbar-text small text-secondary ms-1">a tiny Wordle clone</span>
      <div class="ms-auto d-flex gap-2">
        <button id="btnHelp" class="btn btn-outline-info btn-sm">How to play</button>
        <button id="btnStats" class="btn btn-outline-info btn-sm">Stats</button>
        <div class="ms-2">
          <label class="form-label small text-secondary mb-0">Mode</label>
          <select id="modeSelect" class="form-select form-select-sm bg-dark text-light border-secondary">
            <option value="daily">Daily</option>
            <option value="random">Random</option>
          </select>
        </div>
      </div>
    </div>
  </nav>

  <main class="container-lg my-4">
    <!-- Game Card -->
    <section class="gg-card p-3 mb-3" aria-labelledby="gameTitle">
      <div class="d-flex align-items-center gap-2 pb-2 border-bottom" style="border-color:var(--gg-border) !important;">
        <span class="badge rounded-pill gg-badge" id="gameTitle">Daily Puzzle</span>
        <div class="ms-auto d-flex flex-wrap gap-2">
          <button id="btnNew" class="btn btn-success btn-sm">New word</button>
        </div>
      </div>

      <div class="panel">
        <div class="board" id="board" aria-label="Word grid"></div>
        <div class="mt-3"><div id="keyboard" class="kbd" aria-label="On-screen keyboard"></div></div>
      </div>
    </section>
  </main>

  <!-- Help Modal -->
  <div class="modal fade" id="helpModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered"><div class="modal-content bg-dark text-light border-0">
      <div class="modal-header border-0"><h5 class="modal-title">How to play</h5><button class="btn-close btn-close-white" data-bs-dismiss="modal"></button></div>
      <div class="modal-body">
        <ol class="small mb-0">
          <li>Guess the five‑letter word in six tries.</li>
          <li>Each guess must be a valid word; press <b>Enter</b> to submit.</li>
          <li>Tile colors show how close your guess was: <span class="stat-pill" style="background:var(--tile-correct); border-color:var(--tile-correct)">correct</span> • <span class="stat-pill" style="background:var(--tile-present); border-color:var(--tile-present)">present</span> • <span class="stat-pill" style="background:var(--tile-absent); border-color:var(--tile-absent)">absent</span>.</li>
        </ol>
      </div>
    </div></div>
  </div>

  <!-- Stats Modal -->
  <div class="modal fade" id="statsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered"><div class="modal-content bg-dark text-light border-0">
      <div class="modal-header border-0"><h5 class="modal-title">Stats</h5><button class="btn-close btn-close-white" data-bs-dismiss="modal"></button></div>
      <div class="modal-body">
        <div class="d-flex flex-wrap gap-2 mb-2">
          <span class="stat-pill" id="statPlayed">Played 0</span>
          <span class="stat-pill" id="statWin">Wins 0</span>
          <span class="stat-pill" id="statStreak">Streak 0</span>
        </div>
        <div class="small gg-muted">Stats are stored in your browser.</div>
      </div>
    </div></div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
  "use strict";
  // ===== Word lists (loaded from the web) =====
  // We pull a big Allowed list and a curated Common list for solutions.
  // Sources:
  // 1) Tab Atkins' Wordle list (all valid guesses)
  // 2) DarkerMango 5-letter words (MIT)
  // 3) Shmookey's 3,103 common 5-letter words (solutions pool)
  const WORD_SOURCES = {
    allowed: [
      'https://raw.githubusercontent.com/tabatkins/wordle-list/main/words',
      'https://darkermango.github.io/5-Letter-words/words.txt'
    ],
    common: [
      'https://gist.githubusercontent.com/shmookey/b28e342e1b1756c4700f42f17102c2ff/raw/'
    ]
  };

  // Fallbacks if network fails
  let SOLUTIONS = ['CRANE','MAGIC','RAVEN','PIXEL','PLANT','SOUND','TRACE','CLOUD','BRAVE','FRAME'];
  let ALLOWED = new Set(SOLUTIONS);

  // Robust line parser — avoids broken regex literals by building once here
  const LINE_SPLIT = /\r?\n/;
  const parseLines = (txt)=> txt
      .replace(/\u0000/g,'')
      .split(LINE_SPLIT)
      .map(s=> s.trim().toUpperCase())
      .filter(w=> /^[A-Z]{5}$/.test(w));

  async function loadWordLists(){
    try{
      const fetchText = async (url)=> (await fetch(url, {cache:'force-cache'})).text();
      // Allowed (merge multiple sources)
      let allowed = [];
      for(const url of WORD_SOURCES.allowed){
        try{ const t = await fetchText(url); allowed = allowed.concat(parseLines(t)); }catch(e){ console.warn('Failed allowed src', url, e); }
      }
      // Solutions from curated "common" list
      let common = [];
      for(const url of WORD_SOURCES.common){
        try{ const t = await fetchText(url); common = common.concat(parseLines(t)); }catch(e){ console.warn('Failed common src', url, e); }
      }
      if(allowed.length){ ALLOWED = new Set(allowed); }
      if(common.length){ SOLUTIONS = Array.from(new Set(common)); }
      console.log('Loaded words:', {allowed: ALLOWED.size, solutions: SOLUTIONS.length});
    }catch(err){ console.warn('Word list load failed, using fallbacks', err); }
  }

  // ===== State =====
  const rows = 6, cols = 5;
  let board = [];     // strings per row
  let cursor = 0;     // index within current row
  let row = 0;        // current row
  let solution = 'CRANE'; // temp until load; replaced in init
  let finished = false;

  const els = {
    board: document.getElementById('board'),
    keyboard: document.getElementById('keyboard'),
    btnNew: document.getElementById('btnNew'),
    btnStats: document.getElementById('btnStats'),
    btnHelp: document.getElementById('btnHelp'),
    statPlayed: document.getElementById('statPlayed'),
    statWin: document.getElementById('statWin'),
    statStreak: document.getElementById('statStreak'),
    modeSelect: document.getElementById('modeSelect'),
  };

  // ===== UI build =====
  function buildBoard(){
    board = Array.from({length:rows}, ()=>Array(cols).fill(''));
    els.board.innerHTML = '';
    for(let r=0;r<rows;r++){
      const line = document.createElement('div'); line.className = 'row';
      for(let c=0;c<cols;c++){
        const t = document.createElement('div'); t.className = 'tile'; t.dataset.r=r; t.dataset.c=c; t.setAttribute('aria-label',`r${r+1} c${c+1}`);
        // Enable clicking in current row to move caret and edit that slot
        t.addEventListener('click', ()=> handleTileClick(r,c));
        line.appendChild(t);
      }
      els.board.appendChild(line);
    }
  }

  function buildKeyboard(){
    els.keyboard.innerHTML = '';
    const rowsK = [
      [..."QWERTYUIOP"],
      [..."ASDFGHJKL"],
      ["ENTER",..."ZXCVBNM","DEL"]
    ];
    rowsK.forEach(krow=>{
      const div = document.createElement('div'); div.className='kbd-row';
      krow.forEach(label=>{
        const b = document.createElement('button'); b.className='key'; b.textContent=label; b.dataset.key=label;
        if(label.length>1) b.classList.add('wide');
        b.addEventListener('click', ()=> handleKey(label));
        div.appendChild(b);
      });
      els.keyboard.appendChild(div);
    });
  }

  // ===== Game helpers =====
  function pickDailySolution(){
    const d = new Date();
    const seed = d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate();
    const idx = seed % SOLUTIONS.length;
    return SOLUTIONS[idx];
  }
  function pickRandomSolution(){
    return SOLUTIONS[Math.floor(Math.random()*SOLUTIONS.length)];
  }
  function getMode(){ return localStorage.getItem('wf_mode') || 'daily'; }
  function setMode(mode){ localStorage.setItem('wf_mode', mode); }
  function pickSolutionByMode(){ return getMode()==='random' ? pickRandomSolution() : pickDailySolution(); }

  function toast(msg){
    const t = document.createElement('div'); t.className='toastify'; t.textContent = msg;
    document.body.appendChild(t); setTimeout(()=> t.remove(), 1500);
  }

  function paintBoard(){
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
        tile.textContent = board[r][c];
        tile.classList.toggle('filled', !!board[r][c]);
        // mark editable & active focus indicator for current row
        const isCurrentRow = (r===row && !finished);
        tile.classList.toggle('can-edit', isCurrentRow);
        tile.classList.toggle('active', isCurrentRow && c===cursor);
      }
    }
  }

  async function submitRow(){
    const guess = board[row].join('');
    if(guess.length<cols){ toast('Not enough letters'); return; }
    if(!ALLOWED.has(guess)){ toast('Not in word list'); return; }
    const result = score(guess, solution);
    await revealRow(row, result); // ensure sequential flips
    updateKeyboard(result, guess);
    const won = result.every(x=>x==='correct');
    row++; cursor=0;
    if(won){ endGame(true, guess); }
    else if(row>=rows){ endGame(false, solution); }
    paintBoard();
  }

  function score(guess, target){
    // Wordle rules: first mark greens, then yellows by remaining counts
    const res = Array(cols).fill('absent');
    const targetCounts = {};
    for(let i=0;i<cols;i++){
      const t = target[i];
      if(guess[i]===t){ res[i]='correct'; }
      else targetCounts[t] = (targetCounts[t]||0)+1;
    }
    for(let i=0;i<cols;i++){
      if(res[i]==='correct') continue;
      const g = guess[i];
      if(targetCounts[g]>0){ res[i]='present'; targetCounts[g]--; }
    }
    return res; // array of 'correct' | 'present' | 'absent'
  }

  // Make reveals strictly sequential using animation events (fixes the cascade bug)
  async function revealRow(r, result){
    for(let c=0;c<cols;c++){
      const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
      await new Promise(resolve=>{
        tile.classList.add('reveal');
        tile.addEventListener('animationend', function handler(){
          tile.removeEventListener('animationend', handler);
          tile.classList.remove('reveal');
          tile.classList.add(result[c]);
          resolve();
        }, {once:true});
      });
    }
  }

  function updateKeyboard(result, guess){
    for(let i=0;i<cols;i++){
      const ch = guess[i];
      const key = els.keyboard.querySelector(`[data-key="${ch}"]`);
      if(!key) continue;
      const prev = key.getAttribute('data-state');
      const now = result[i];
      if(prev==='correct') continue; // don't downgrade
      if(prev==='present' && now==='absent') continue;
      key.setAttribute('data-state', now);
    }
  }

  function endGame(won, word){
    finished = true;
    saveStats(won);
    toast(won ? 'You solved it!' : `The word was ${word}`);
    updateStatsUI();
  }

  // ===== Stats =====
  function readStats(){ try{ return JSON.parse(localStorage.getItem('gw_stats')||'{}'); }catch(e){ return {}; } }
  function writeStats(s){ try{ localStorage.setItem('gw_stats', JSON.stringify(s)); }catch(e){} }
  function saveStats(won){
    const s = readStats();
    s.played = (s.played||0)+1;
    s.win = (s.win||0) + (won?1:0);
    s.streak = won ? ( (s.lastWinToday===todayKey()) ? (s.streak||0) : ( (s.lastWin||0)===yesterdayKey() ? (s.streak||0)+1 : 1) ) : 0;
    if(won){ s.lastWin = todayKey(); s.lastWinToday = todayKey(); }
    writeStats(s);
  }
  const todayKey = ()=> new Date().toISOString().slice(0,10);
  const yesterdayKey = ()=>{ const d=new Date(); d.setDate(d.getDate()-1); return d.toISOString().slice(0,10); };
  function updateStatsUI(){
    const s = readStats();
    els.statPlayed.textContent = `Played ${s.played||0}`;
    els.statWin.textContent = `Wins ${s.win||0}`;
    els.statStreak.textContent = `Streak ${s.streak||0}`;
  }

  // ===== Input & editing =====
  function handleKey(k){ if(finished) return; if(k==='ENTER') submitRow(); else if(k==='DEL') backspace(); else if(/^[A-Z]$/.test(k)) type(k); }
  function type(ch){ if(cursor>=cols) return; board[row][cursor]=ch; cursor=Math.min(cursor+1, cols-1); paintBoard(); }
  function backspace(){
    // delete previous slot (classic Wordle behavior). If at col 0, clear current.
    if(cursor>0){ cursor--; board[row][cursor]=''; }
    else { board[row][cursor]=''; }
    paintBoard();
  }
  function setCursor(col){ cursor = Math.max(0, Math.min(cols-1, col)); paintBoard(); }
  function moveLeft(){ setCursor(cursor-1); }
  function moveRight(){ setCursor(cursor+1); }
  function handleTileClick(r,c){ if(finished) return; if(r!==row) return; setCursor(c); }

  document.addEventListener('keydown', (e)=>{
    if(finished) return;
    const key = e.key;                // keep original for arrows
    const k = key.toUpperCase();      // uppercase for letters/control names

    if(key==='ArrowLeft'){ e.preventDefault(); moveLeft(); return; }
    if(key==='ArrowRight'){ e.preventDefault(); moveRight(); return; }

    if(k==='ENTER'){ e.preventDefault(); submitRow(); }
    else if(k==='BACKSPACE'){ e.preventDefault(); backspace(); }
    else if(k==='DELETE'){ e.preventDefault(); board[row][cursor]=''; paintBoard(); }
    else if(/^[A-Z]$/.test(k) && k.length===1){ type(k); }
  });

  // ===== Controls =====
  els.btnNew.addEventListener('click', ()=>{
    const mode = getMode();
    const next = pickSolutionByMode();
    if(mode==='daily' && next===solution){ toast('Daily mode — same word for today'); }
    solution = next;
    resetGame();
    toast('New word!');
  });
  els.btnHelp.addEventListener('click', ()=> new bootstrap.Modal(document.getElementById('helpModal')).show());
  els.btnStats.addEventListener('click', ()=>{ updateStatsUI(); new bootstrap.Modal(document.getElementById('statsModal')).show(); });
  function resetGame(){
    finished=false; row=0; cursor=0; buildBoard(); buildKeyboard(); paintBoard();
    els.keyboard.querySelectorAll('.key').forEach(k=> k.removeAttribute('data-state'));
  }

  // Mode UI wiring (if markup ever changes, we can inject)
  function ensureModeUI(){
    if(!els.modeSelect){
      const container = document.querySelector('.navbar .container-lg .ms-auto');
      if(container){
        const wrap = document.createElement('div');
        wrap.className = 'ms-2';
        wrap.innerHTML = `
          <label class="form-label small text-secondary mb-0">Mode</label>
          <select id="modeSelect" class="form-select form-select-sm bg-dark text-light border-secondary">
            <option value="daily">Daily</option>
            <option value="random">Random</option>
          </select>`;
        container.appendChild(wrap);
        els.modeSelect = wrap.querySelector('#modeSelect');
      }
    }
  }
  function wireModeUI(){
    ensureModeUI();
    if(!els.modeSelect) return; // nothing to wire
    els.modeSelect.value = getMode();
    els.modeSelect.onchange = ()=>{
      setMode(els.modeSelect.value);
      solution = pickSolutionByMode();
      resetGame();
      toast(`Mode: ${getMode()}`);
    };
  }

  // ===== Dev self-tests (console only) =====
  function runSelfTests(){
    try{
      const results=[]; const assert=(n,c)=>results.push(`${c?'✅':'❌'} ${n}`);
      // parseLines
      const p1 = parseLines('abcde\nxxxxx');
      assert('parseLines keeps 5 letters', p1.includes('ABCDE'));
      assert('parseLines filters non-5', parseLines('abcd\nabcdef').length===0);
      // score correctness
      const s1 = score('CRANE','CRATE');
      assert('score CRANE vs CRATE', JSON.stringify(s1)===JSON.stringify(['correct','correct','correct','absent','correct']));
      const s2 = score('APPLE','ALLEY');
      assert('score APPLE vs ALLEY', JSON.stringify(s2)===JSON.stringify(['correct','absent','absent','present','present']));
      const s3 = score('ALLEY','BALMY');
      assert('score ALLEY vs BALMY (dupes)', JSON.stringify(s3)===JSON.stringify(['present','absent','correct','absent','present']));
      // caret/typing behavior (non-destructive)
      const snap = {row, cursor, board: board.map(r=> r.slice())};
      try{
        row=0; cursor=0; board[0]=Array(cols).fill('');
        type('A'); moveRight(); type('B'); moveLeft(); backspace();
        assert('caret move + type + backspace', board[0][0]==='A' && board[0][1]==='');
      } finally { row=snap.row; cursor=snap.cursor; board=snap.board; paintBoard(); }
      const out = results.join('\n');
      console.log(`[Wordflux self-tests]\n${out}`);
    }catch(e){ console.error('self-tests threw', e); }
  }

  // ===== Init =====
  (async ()=>{
    await loadWordLists();
    wireModeUI();
    solution = pickSolutionByMode();
    buildBoard(); buildKeyboard(); paintBoard(); updateStatsUI();
    if (location.search.includes('dev=1')) runSelfTests();
  })();
  </script>
</body>
</html>
